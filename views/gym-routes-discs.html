


{% extends "skala3ma-layout.html" %}

{% block topcontent %}

{% include "gym-menu.html" %}

{% endblock %}


	{% block secondarycontent %}





<div class=" container-fluid " >
    <div class="row">

      
        <div class="col text-end justify-content-end p-4">
            <img src="/image/{{  gym.get('logo_img_id') }}"  width="250"/>
            </div>
            <div class="col justify-content-left align-items-center">
       <br>
                <h1  class="display-4"> {{ gym['name'] }}</h1> 
                
                <div class="row">
                    <div class="col-1 text-end">
                         <label for="default_routes" class="col-form-label">{{ reference_data['current_language'].routes }}:  </label>
                     </div>
                     <div class="col">
                         <select name="default_routes" class="form-select" id="default_routes" onchange="document.location.href=`/gyms/{{ gym['id'] }}/${this.value}/discs`">
             
                         {% for route in all_routes %}
                             <option name="id" value="{{all_routes[route]['id']}}" {% if all_routes[route]['id'] == routes['id'] %} selected {% endif %}  >{{all_routes[route]['name']}}</option>
                         {% endfor %}
             
                         </select>
                     </div>
                 </div>
                 <div class="row mt-2 align-items-center g-2" id="disc-controls">
                    <div class="col-auto text-end">
                        <label for="min_per_disc" class="col-form-label small mb-0">Min / Max</label>
                    </div>
                    <div class="col-auto">
                        <input type="number" class="form-control form-control-sm" id="min_per_disc" min="3" max="15" step="1" value="4" />
                    </div>
                    <div class="col-auto">
                        <input type="number" class="form-control form-control-sm" id="max_per_disc" min="4" max="15" step="1" value="8" />
                    </div>
                    <div class="col-auto small text-muted" id="disc-controls-msg"></div>
                    <div class="col d-flex">
                        <button type="button" id="print_discs_btn" class="btn btn-sm btn-outline-secondary ms-auto w-100 text-start text-nowrap" title="Print discs (one per page)">
                            <i class="icon-print"></i> Print
                        </button>
                    </div>
                 </div>

        </div>
      
    </div>
    
    
</div>
    



<div class="container-fluid text-center justify-content-left">  
   

                   <script>
                    // Disc visualization logic for gym routes
                    // Requirements implemented:
                    //  * Maintain original route order
                    //  * Group into discs of 5..10 routes (soft preferred size)
                    //  * Each disc: no duplicate color1, at most 2 distinct lines
                    //  * Render each disc as an SVG radial chart ("disc") with slices colored
                    //  * color_modifier "marble" -> gradient / mixed look
                    //  * Provide small badges for quick route reference
                    //  * Responsive card grid

                    const userConfig = {
                        gymid: "{{gymid}}",
                        routeListId: "{{routesid}}",
                        preferredRoutesPerDisc: 8, // soft target
                        minPerDisc: 4,
                        maxPerDisc: 8,
                        discSizePx: 220,
                        faviconPath: '/public/images/favicon.png'
                    };

                    let __cachedRoutes = [];

                    function lightenColor(hex, amt = 30) {
                        if(!hex) return '#cccccc';
                        let h = hex.replace('#','');
                        if (h.length === 3) h = h.split('').map(c=>c+c).join('');
                        let nums = [0,2,4].map(i=>parseInt(h.substring(i,i+2),16));
                        nums = nums.map(v=>Math.min(255,Math.max(0,v+amt)));
                        return '#'+nums.map(v=>v.toString(16).padStart(2,'0')).join('');
                    }

                    function darkenColor(hex, amt = 30) {
                        if(!hex) return '#666666';
                        let h = hex.replace('#','');
                        if (h.length === 3) h = h.split('').map(c=>c+c).join('');
                        let nums = [0,2,4].map(i=>parseInt(h.substring(i,i+2),16));
                        nums = nums.map(v=>Math.min(255,Math.max(0,v-amt)));
                        return '#'+nums.map(v=>v.toString(16).padStart(2,'0')).join('');
                    }

                    // Deterministic pseudo random for repeatable patterns per disc/slice
                    function prng(seed) {
                        return function() {
                            seed = (seed * 9301 + 49297) % 233280;
                            return seed / 233280;
                        }
                    }

                    function hexToRgb(hex) {
                        if(!hex) return {r:128,g:128,b:128};
                        let h = hex.replace('#','');
                        if (h.length === 3) h = h.split('').map(c=>c+c).join('');
                        return {r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)};
                    }
                    function rgbToHex(r,g,b){return '#'+[r,g,b].map(v=>Math.min(255,Math.max(0,Math.round(v))).toString(16).padStart(2,'0')).join('');}
                    function getRelLumFromRgb(r,g,b){
                        const sr=[r,g,b].map(v=>{v/=255;return v<=0.03928? v/12.92:Math.pow((v+0.055)/1.055,2.4)});
                        return 0.2126*sr[0]+0.7152*sr[1]+0.0722*sr[2];
                    }
                    function contrastRatioHex(a,b){
                        const ar=hexToRgb(a), br=hexToRgb(b);
                        const l1=getRelLumFromRgb(ar.r,ar.g,ar.b), l2=getRelLumFromRgb(br.r,br.g,br.b);
                        const hi=Math.max(l1,l2), lo=Math.min(l1,l2);
                        return (hi+0.05)/(lo+0.05);
                    }
                    function shiftTowards(hex, target='light', amount=60){
                        return target==='light'? lightenColor(hex,amount): darkenColor(hex,amount);
                    }
                    function generateVariantColors(base){
                        // ensure at least one variant with adequate contrast ratio
                        const variants = [];
                        const baseLum = getLuminance(base);
                        // Primary variant direction opposite of base brightness
                        let primary = baseLum < 0.45 ? shiftTowards(base,'light',70) : shiftTowards(base,'dark',70);
                        // Adjust until contrast ratio threshold reached
                        let step = 10; let attempts=0;
                        while (contrastRatioHex(base, primary) < 3 && attempts<6){
                            primary = baseLum < 0.45 ? shiftTowards(primary,'light',step) : shiftTowards(primary,'dark',step);
                            attempts++;
                        }
                        variants.push(primary);
                        // Secondary variant mid-tone between base and primary for more texture
                        const br = hexToRgb(base); const pr = hexToRgb(primary);
                        const mid = rgbToHex((br.r+pr.r)/2,(br.g+pr.g)/2,(br.b+pr.b)/2);
                        // If mid too close to base choose stronger alt
                        const midContrast = contrastRatioHex(base, mid);
                        variants.push(midContrast < 2.2 ? (baseLum<0.45? shiftTowards(base,'light',40): shiftTowards(base,'dark',40)) : mid);
                        return variants;
                    }

                    function generateCamoPattern(baseColor, discIndex, sliceIndex, size) {
                        const patId = `camo_${discIndex}_${sliceIndex}`;
                        const rand = prng((discIndex+1)*1000 + sliceIndex*97 + baseColor.length*31);
                        // Derive variant colors with enforced contrast
                        const [varA, varB] = generateVariantColors(baseColor);
                        const darkRef = contrastRatioHex(baseColor,varA) > contrastRatioHex(baseColor,varB) ? varA: varB;
                        const patchCount = 8 + Math.floor(rand()*6); // 8-13 patches for richer texture
                        // We'll build organic-ish blobs using path composed of arcs (simplified) or circles with slight scale.
                        const w = size, h = size; // pattern size in user units
                        let shapes = [`<rect width="${w}" height="${h}" fill="${baseColor}"/>`];
                        for (let i=0; i<patchCount; i++) {
                            const color = rand() > 0.45 ? varA : varB;
                            const cx = (rand()*w);
                            const cy = (rand()*h);
                            const rBase = (Math.min(w,h) * (0.12 + rand()*0.18));
                            // Create blobby path by overlapping 3 circles (simplified union look)
                            const offset1x = cx + rBase*0.6*(rand()-0.5);
                            const offset1y = cy + rBase*0.6*(rand()-0.5);
                            const offset2x = cx + rBase*0.6*(rand()-0.5);
                            const offset2y = cy + rBase*0.6*(rand()-0.5);
                            shapes.push(`<g fill="${color}" fill-opacity="0.9">`+
                                        `<circle cx="${cx.toFixed(1)}" cy="${cy.toFixed(1)}" r="${rBase.toFixed(1)}"/>`+
                                        `<circle cx="${offset1x.toFixed(1)}" cy="${offset1y.toFixed(1)}" r="${(rBase*0.8).toFixed(1)}"/>`+
                                        `<circle cx="${offset2x.toFixed(1)}" cy="${offset2y.toFixed(1)}" r="${(rBase*0.65).toFixed(1)}"/>`+
                                        `</g>`);
                        }
                        // Add higher-contrast speckles to increase visibility on very dark colors
                        const speckCount = 22;
                        for (let s=0; s<speckCount; s++) {
                            const scx = rand()*w;
                            const scy = rand()*h;
                            const sr = 1 + rand()*2.4;
                            shapes.push(`<circle cx="${scx.toFixed(1)}" cy="${scy.toFixed(1)}" r="${sr.toFixed(1)}" fill="${darkRef}" fill-opacity="0.55"/>`);
                        }
                        return `<pattern id="${patId}" patternUnits="userSpaceOnUse" width="${w}" height="${h}">`+ shapes.join('') + `</pattern>`;
                    }

                    function getLuminance(hex) {
                        if(!hex) return 0.5;
                        let h = hex.replace('#','');
                        if (h.length === 3) h = h.split('').map(c=>c+c).join('');
                        const r = parseInt(h.slice(0,2),16)/255;
                        const g = parseInt(h.slice(2,4),16)/255;
                        const b = parseInt(h.slice(4,6),16)/255;
                        const a=[r,g,b].map(v=> v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055,2.4));
                        return 0.2126*a[0] + 0.7152*a[1] + 0.0722*a[2];
                    }

                    function getContrastLineColor(base) {
                        const lum = getLuminance(base||'#888888');
                        // choose dark for light backgrounds and light for dark backgrounds
                        return lum > 0.55 ? 'rgba(30,30,30,0.55)' : 'rgba(255,255,255,0.55)';
                    }

                    function groupRoutesIntoDiscs(routes, cfg) {
                        const discs = [];
                        let current = [];
                        let colors = new Set();
                        let lines = new Set();

                        function reset() { current = []; colors = new Set(); lines = new Set(); }
                        function finalize() { if (current.length) { discs.push(current); reset(); } }

                        for (let i=0;i<routes.length;i++) {
                            const rt = routes[i];
                            const color = (rt.color1||'#888888').trim();
                            const line = (rt.line||'na').trim();
                            const colorConflict = colors.has(color);
                            const lineLimit = !lines.has(line) && lines.size === 2;
                            const sizeLimit = current.length >= cfg.maxPerDisc;

                            if (current.length === 0) {
                                current.push(rt); colors.add(color); lines.add(line); continue;
                            }

                            if (!colorConflict && !lineLimit && !sizeLimit) {
                                current.push(rt); colors.add(color); lines.add(line); continue;
                            }

                            if (current.length >= cfg.minPerDisc) {
                                finalize();
                                current.push(rt); colors.add(color); lines.add(line); continue;
                            }

                            // Need to reach minimum size but blocked: attempt limited look-ahead reorder
                            if (colorConflict || lineLimit) {
                                let inserted = false;
                                for (let j=i+1; j<routes.length && j<i+6; j++) { // peek ahead a few
                                    const cand = routes[j];
                                    const cColor = (cand.color1||'#888888').trim();
                                    const cLine = (cand.line||'na').trim();
                                    if (!colors.has(cColor) && (lines.has(cLine) || lines.size < 2)) {
                                        routes.splice(j,1);
                                        routes.splice(i,0,cand);
                                        inserted = true; i--; // reprocess this index with candidate
                                        break;
                                    }
                                }
                                if (inserted) continue;
                            }

                            // Fallback: try merge with previous disc if possible, else finalize early
                            if (current.length < cfg.minPerDisc) {
                                const prev = discs[discs.length-1];
                                if (prev) {
                                    let prevColors = new Set(prev.map(r=> (r.color1||'#888888').trim()));
                                    let prevLines = new Set(prev.map(r=> (r.line||'na').trim()));
                                    let canMerge = true;
                                    if (prev.length + current.length > cfg.maxPerDisc) canMerge = false;
                                    if (canMerge) {
                                        for (const r of current) {
                                            const c = (r.color1||'#888888').trim();
                                            const l = (r.line||'na').trim();
                                            if (prevColors.has(c)) { canMerge = false; break; }
                                            if (!prevLines.has(l) && prevLines.size===2) { canMerge = false; break; }
                                        }
                                    }
                                    if (canMerge) {
                                        current.forEach(r=>{ prev.push(r); prevColors.add((r.color1||'#888888').trim()); prevLines.add((r.line||'na').trim()); });
                                        reset();
                                    } else {
                                        finalize();
                                    }
                                } else {
                                    finalize();
                                }
                                // Start new disc with rt
                                current.push(rt); colors.add(color); lines.add(line); continue;
                            }
                        }
                        finalize();
                        return discs;
                    }

                    function createDiscSVG(discRoutes, cfg, discIndex) {
                        const size = cfg.discSizePx;
                        const r = size/2;
                        const cx=r, cy=r;
                        const n = discRoutes.length;
                        const anglePer = 2*Math.PI / n;
                        const svg = [];
                        const defs = [];
                        svg.push(`<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" class="disc-svg" data-disc="${discIndex}">`);
                        svg.push('<defs>');
                        const faviconSize = r * 0.45; // relative size of center icon
                        // Clip path for favicon so it stays circular
                        defs.push(`<clipPath id="clip_favicon_${discIndex}"><circle cx="${cx}" cy="${cy}" r="${(faviconSize/2).toFixed(2)}" /></clipPath>`);
                        discRoutes.forEach((rt,i)=>{
                            if (rt.color_modifier === 'marble') {
                                const base = (rt.color1||'#999999').trim();
                                // pattern size relative to full disc to have a few patches per slice
                                const patternSize = size * 0.4; 
                                defs.push(generateCamoPattern(base, discIndex, i, patternSize));
                            }
                        });
                        svg.push(defs.join(''));
                        svg.push('</defs>');
                        discRoutes.forEach((rt,i)=>{
                            const start = i*anglePer - Math.PI/2;
                            const end = start + anglePer;
                            const x1 = cx + r*Math.cos(start);
                            const y1 = cy + r*Math.sin(start);
                            const x2 = cx + r*Math.cos(end);
                            const y2 = cy + r*Math.sin(end);
                            const largeArc = anglePer > Math.PI ? 1 : 0;
                            const d = `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2} Z`;
                            const fill = rt.color_modifier === 'marble' ? `url(#camo_${discIndex}_${i})` : (rt.color1 || '#999999');
                            const routeNum = rt.routenum || (i+1);
                            const label = (rt.grade || '').trim() || '?';
                            const mid = start + anglePer/2;
                            const lr = r*0.62;
                            const lx = cx + lr*Math.cos(mid);
                            const ly = cy + lr*Math.sin(mid);
                            const fontSize = Math.max(10,(r/6));
                            const textWidth = Math.max(label.length * fontSize * 0.6, fontSize*1.4);
                            const textHeight = fontSize * 1.1;
                            const rectX = lx - textWidth/2 - 3;
                            const rectY = ly - textHeight/2 - 2;
                            const rectW = textWidth + 6;
                            const rectH = textHeight + 4;
                            svg.push(`<path d="${d}" fill="${fill}" stroke="#222" stroke-width="1" data-route-id="${rt.id}"><title>#${routeNum} ${rt.grade||''} line:${rt.line||''}</title></path>`);
                            // (Removed contour lines for marble to emphasize camouflage pattern)
                            svg.push(`<g pointer-events="none">`+
                                     `<rect x="${rectX.toFixed(1)}" y="${rectY.toFixed(1)}" rx="4" ry="4" width="${rectW.toFixed(1)}" height="${rectH.toFixed(1)}" fill="rgba(255,255,255,0.85)" stroke="rgba(0,0,0,0.15)" stroke-width="1"/>`+
                                     `<text x="${lx.toFixed(1)}" y="${ly.toFixed(1)}" text-anchor="middle" dominant-baseline="middle" font-size="${fontSize.toFixed(0)}" fill="#111" style="font-family:Arial,sans-serif;font-weight:600;">${label}</text>`+
                                     `</g>`);
                        });
                        svg.push(`<circle cx="${cx}" cy="${cy}" r="${r-0.5}" fill="none" stroke="#555" stroke-width="2"/>`);
                        // Base circle backdrop (slightly larger than favicon) for contrast
                        svg.push(`<circle cx="${cx}" cy="${cy}" r="${(faviconSize/2 + 4).toFixed(2)}" fill="#ffffffdd" stroke="#444" stroke-width="1"/>`);
                        // Favicon image (will fail silently if not found)
                        svg.push(`<image href="${cfg.faviconPath}" x="${(cx - faviconSize/2).toFixed(2)}" y="${(cy - faviconSize/2).toFixed(2)}" width="${faviconSize.toFixed(2)}" height="${faviconSize.toFixed(2)}" preserveAspectRatio="xMidYMid meet" clip-path="url(#clip_favicon_${discIndex})" />`);
                        svg.push('</svg>');
                        return svg.join('');
                    }

                    function displayRouteDiscs(routes, cfg) {
                        const container = document.getElementById('discs-gallery');
                        if (!container) return;
                        if (!Array.isArray(routes)) { console.warn('No routes array'); return; }
                        const discs = groupRoutesIntoDiscs([...routes], cfg);
                        container.innerHTML = '';
                        discs.forEach((discRoutes, idx) => {
                            const col = document.createElement('div');
                            col.className = 'col-12 col-sm-6 col-md-4 col-lg-3 mb-3';
                            const lines = [...new Set(discRoutes.map(r=>r.line))].filter(Boolean).join(', ');
                                                        col.innerHTML = `
                                                            <div class="card shadow-sm h-100">
                                                                <div class="card-header p-1 text-center">Disc ${idx+1} <small class="text-muted">(${discRoutes.length} | line: ${lines||'n/a'})</small></div>
                                                                <div class="card-body d-flex flex-column align-items-center justify-content-center">${createDiscSVG(discRoutes, cfg, idx)}</div>
                                                            </div>`;
                            container.appendChild(col);
                        });
                    }

                    fetch(`/api1/gym/${userConfig.gymid}/${userConfig.routeListId}`)
                        .then(r=>r.json())
                        .then(data=>{
                            console.log('Fetched routes:', data?.routes?.length);
                            __cachedRoutes = data.routes || [];
                            displayRouteDiscs(__cachedRoutes, userConfig);
                            initDiscControls();
                            initPrintDiscs();
                        })
                        .catch(err=>console.error('Error fetching routes data:', err));

                    function initDiscControls() {
                        const minInput = document.getElementById('min_per_disc');
                        const maxInput = document.getElementById('max_per_disc');
                        const msg = document.getElementById('disc-controls-msg');
                        if (!minInput || !maxInput) return;

                        function validateAndRender() {
                            let minVal = parseInt(minInput.value,10);
                            let maxVal = parseInt(maxInput.value,10);
                            if (isNaN(minVal) || isNaN(maxVal)) return;
                            if (minVal < 1) minVal = 1;
                            if (maxVal < minVal) maxVal = minVal;
                            // apply simple practical limits
                            if (minVal > 15) minVal = 15;
                            if (maxVal > 15) maxVal = 15;
                            minInput.value = minVal;
                            maxInput.value = maxVal;
                            userConfig.minPerDisc = minVal;
                            userConfig.maxPerDisc = maxVal;
                            //msg.textContent = `Grouping: ${minVal}-${maxVal}`;
                            displayRouteDiscs(__cachedRoutes, userConfig);
                        }

                        minInput.addEventListener('input', validateAndRender);
                        maxInput.addEventListener('input', validateAndRender);
                        // Up/down arrow immediate effect already via input event; also handle wheel accidentally
                        minInput.addEventListener('change', validateAndRender);
                        maxInput.addEventListener('change', validateAndRender);
                        validateAndRender();
                    }

                    // Print logic: one disc per page
                    function initPrintDiscs() {
                        const btn = document.getElementById('print_discs_btn');
                        if(!btn) return;
                        btn.addEventListener('click', () => {
                            document.body.classList.add('print-discs-mode');
                            // Optionally enlarge SVGs dynamically by scaling attribute if needed
                            const originalSizes = [];
                            document.querySelectorAll('.print-discs-mode .disc-svg').forEach(svg => {
                                originalSizes.push({svg, w: svg.getAttribute('width'), h: svg.getAttribute('height')});
                                svg.setAttribute('width','700');
                                svg.setAttribute('height','700');
                            });
                            const cleanup = () => {
                                document.body.classList.remove('print-discs-mode');
                                originalSizes.forEach(({svg,w,h})=>{ if (w) svg.setAttribute('width',w); if (h) svg.setAttribute('height',h); });
                                window.removeEventListener('afterprint', cleanup);
                            };
                            window.addEventListener('afterprint', cleanup);
                            window.print();
                        });
                    }
                    </script>
                    <style>
                        #discs-gallery .card { transition: box-shadow .2s, transform .2s; }
                        #discs-gallery .card:hover { box-shadow: 0 .5rem 1rem rgba(0,0,0,.15); transform: translateY(-3px); }
                        .disc-svg { max-width: 100%; height: auto; }
                        .disc-svg text { font-weight: 600; }
                        .disc-svg image { pointer-events: none; }
                        /* Controls layout enhancements */
                        #disc-controls { --disc-gap: .5rem; }
                        #disc-controls input { min-width: 70px; }
                        #print_discs_btn { transition: background-color .15s, color .15s, box-shadow .15s; }
                        #print_discs_btn.btn-outline-secondary { 
                            background: linear-gradient(180deg, #f8f9fa 0%, #eceeef 100%);
                            color: #444;
                            border-color: #adb5bd;
                        }
                        #print_discs_btn.btn-outline-secondary:hover,
                        #print_discs_btn.btn-outline-secondary:focus { 
                            background: #6c757d; 
                            color: #fff; 
                            border-color: #6c757d; 
                        }
                        #print_discs_btn:active { 
                            background:#5a6268!important; 
                            color:#fff!important; 
                            box-shadow: inset 0 2px 4px rgba(0,0,0,0.25);
                        }
                        #print_discs_btn i { margin-right: .35rem; }
                        @media print {
                            body.print-discs-mode #disc-controls, 
                            body.print-discs-mode nav, 
                            body.print-discs-mode header, 
                            body.print-discs-mode footer, 
                            body.print-discs-mode .navbar { display: none !important; }
                            /* Hide any gym menu structures */
                            body.print-discs-mode #gym-menu,
                            body.print-discs-mode .gym-menu,
                            body.print-discs-mode [class*='menu'],
                            body.print-discs-mode [id*='menu'] { display: none !important; }
                            /* Hide the first container (logo / header block) to avoid blank first page */
                            body.print-discs-mode .container-fluid:first-of-type { display: none !important; }
                            /* Explicitly hide logo, gym name, and route selector if still present */
                            body.print-discs-mode img[src*='/image/'][width],
                            body.print-discs-mode h1.display-4,
                            body.print-discs-mode select#default_routes,
                            body.print-discs-mode label[for='default_routes'],
                            body.print-discs-mode #default_routes { display: none !important; }
                            body.print-discs-mode .row:has(#default_routes) { display: none !important; }
                            /* Hide print button itself */
                            body.print-discs-mode #print_discs_btn { display:none !important; }
                            body.print-discs-mode #discs-gallery { display: block; }
                            body.print-discs-mode #discs-gallery > div { page-break-after: always; break-after: page; width: 100% !important; margin: 0 !important; }
                            body.print-discs-mode #discs-gallery > div:last-child { page-break-after: auto; break-after: auto; }
                            body.print-discs-mode #discs-gallery .card { box-shadow: none !important; border: none !important; }
                            body.print-discs-mode #discs-gallery .card-header { text-align: center; font-size: 18pt; border: none; }
                            body.print-discs-mode #discs-gallery .card-body { display: flex; justify-content: center; align-items: center; min-height: auto; padding: 1rem 0; }
                        }
                    </style>
                
                    <div class="row mt-3" id="discs-gallery" aria-live="polite"></div>
            </div>
        </div>

    </div>






{% endblock %}